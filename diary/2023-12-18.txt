2023-12-18


탄알의 구현 방식을 바꾸었다.
예전 버전에서는
총을 발사할 때, 그 총의 SubItem의 0번째 인덱스에 존재하는 Item 객체의 StackCount가 하나씩 줄어들고,
재장전할 때, 총 내부에 있는 탄창의 크기 멤버 변수만큼 StackCount를 변경하는 방식이었다.
그리고 총알이 발사되는것을 실행하는 함수는은 어디까지나 총의 객체가 가지고 있었다.
해당 방식의 문제점은
데미지의 기준은 어디까지나 총알이 아닌 총에 있고,
추가적으로 한개의 탄창에 여러개의 탄환을 쑤셔넣을 수 없게 되는 것이다.
ㄴ예를 들어서 총에 첫 탄환은 공포탄을 넣고, 두번째 탄환에는 고무탄을 넣고, 세번째 탄환에는 실탄을 넣고 이런 방식

>> Q. 그게 문제인가요?
지금 생각해보니 그건 크게 문제되지 않은 것 같다. 무안하네.
앞으로는 그게 문제인지부터 질문해야겠다.

어쨌든 나는 그당시 문제삼아버렸고,
나는 다음과 같은 해결하였다.

어쨌든 내가 어떻게 바꾸었냐면
총알이 발사되는 함수를 각자의 탄알 객체가 가지고 있게 만들었다.
총이 발사할 때 탄알 인터페이스에 있는 Activate라는 이름의 함수를 실행시키면, 탄알이 그 함수를 어떻게 구현했는지에 따라서 달라진다.
예를 들어서 벅샷은 조그만 납탄이 여러개 산탄될 것이고, 슬러그 탄은 커다란 탄알이 날아갈것이다.

그러면 총 내부에 탄알 객체가 여러개 들어갈 것이므로, 이것을 담는 탄알집(매거진) 클래스를 따로 만들었다.
총을 발사할때, (SubItem의 0번째 인덱스)챔버에 있는 탄알 객체의 Activate 함수를 실행시킬 것인데, 그 이후에 자동적으로 다음 탄알을 매거진에서 꺼내서 챔버에 넣는 것이다.
탄알집에서 총알이 다 나가서 R키로 재장전 하면, SubItem의 1번째 인덱스에 탄알집을 새로 끼우고,
챔버에 탄알이 없으면 덤으로 새롭게 끼워진 매거진에서 탄알을 꺼내서 집어넣는다.4


그런데 거기서 문제가 생겼는데,
임시로 만든 재장전 함수는 총알 객체를 탄알 사이즈 만큼 탄알집에 채우는 함수였다.
그런데 반복문을 돌리면서 각 칸에 객체를 채우는데 여기서 얕은 복사가 일어난 것.
따라서 SubItem중 하나의 탄환이 바뀌게 되면, 각 SubItem이 가리키는 객체는 얕은 복사로 인해 단 하나인 상황이므로, 모든 탄환에 변화가 생기게 되는 문제가 생겼다.
따라서 여러 객체를 만들때, 각 객체의 독립적 변화가 필요한 경우에 깊은 복사를 하는 방법을 알아야 한다.


디버깅 과정에서 해결하는 과정에서 어떤 함수가 호출이 되었고, 조건문에서 어느 길로 들어갔는지를 잘 추적하는것이 중요하다고 생각한다. 나는 그 과정에서 콘솔에서 문자열을 호출하는 방식으로 해결해왔는데 더 빠른 방법이 있을지 모르겠다.